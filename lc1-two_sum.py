"""
// lc1-two_sum.py :
// Given an array of integers, return indices of the two numbers such that they add up to a specific target.
// You may assume that each input would have exactly one solution, and you may not use the same element twice.

// Example:
//   Given nums = [2, 7, 11, 15], target = 9,
//   Because nums[0] + nums[1] = 2 + 7 = 9,
//   return[0, 1].

// Hint 1: A really brute force way would be to search for all possible pairs of numbers but that would be too 
// slow. Again, it's best to try out brute force solutions for just for completeness. It is from these brute 
// force solutions that you can come up with optimizations.

// Hint 2: So, if we fix one of the numbers, say
// x
// , we have to scan the entire array to find the next number
// y
// which is
// value - x
// where value is the input parameter.Can we change our array somehow so that this search becomes faster ?

// Hint 3: The second train of thought is, without changing the array, can we use additional space somehow? 
// Like maybe a hash map to speed up the search?
"""

def main():
    test_list = [2, 7, 11, 15]
    sln = Solution()
    indexes = sln.twoSum(test_list, 18)

    if indexes: print("Solution Indexes:", indexes)
    else: print("No Solution!")

class Solution:
    def twoSum(self, nums, target):
        ht = {}
        for i in range(len(nums)):
            if ht.get(target-nums[i]) is not None:
                return i, ht[target-nums[i]]
            else:
                ht[nums[i]] = i
        return None

if __name__ == '__main__':
    main()